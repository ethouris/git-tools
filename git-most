#!/usr/bin/tclsh

set screwpath 1
if { "-l" in $argv } {
	set screwpath 1
} elseif { "-g" in $argv } {
	set screwpath -1
} elseif { "-a" in $argv } {
	set screwpath 0
}

set git_options "--porcelain"

set only ""
set onlyin ""

set onlyopt [lsearch -inline $argv -o*]
if { $onlyopt != "" } {
	set oo [string range $onlyopt 2 end]
	while 1 {
		switch -- [string index $oo 0] {
			m { set only mod }
			a { set only add }
			d { set only del }
			o { set only ??? }
			u { set only ??? }
			s { set onlyin stage; set oo [string range $oo 1 end]; continue }
			v { set onlyin view; set oo [string range $oo 1 end]; continue }
			default {
				puts stderr "Incorrect -o (only) option: use one of: m, a, d, o, s, v"
				exit 1
			}
		}
		break
	}
}

# Show untacked (also if untracked-only)
if { "-u" ni $argv && $only != "???" } {
	lappend git_options -uno
}


set args ""
foreach a $argv {
	if { [string index $a 0] != "-" } {
		lappend args $a
	}
}

set top [exec git rev-parse --show-toplevel]

set gitdir $top/.git

if { [file isfile $gitdir] } {
	set gitdirspec [exec cat $gitdir]
	set gitdir [file join $top [lindex $gitdirspec 1]]
}

if { $only == "" } {

lassign [exec cat $gitdir/HEAD] hdx path
if { $hdx == "ref:" } {
	set brname [file tail $path]

	# Find the branch in the configuration
	if { [catch {set reponame [exec git config branch.$brname.remote]}] } {
		set reponame ""
	}
	if { $reponame == "" } { 
		set hosted "(LOCAL)"
	} else { 
		set repourl [exec git config remote.$reponame.url]
		set hosted "$reponame ($repourl)"
	}

	if { ![catch {set hh [exec git show --format=format:%H HEAD]}] } {
		set hh [lindex [split $hh \n] 0]
		set hhs [string range $hh 0 7]
	} else {
		set hh ""
		set hhs "<TO-BE-SET>"  ;# The initial case when HEAD does not exist
	}

	set distance " (distance not supported)"
	# This is not supported up to git 1.7.1, just blindly try.
	if { ![catch {exec git status --short --branch} outlines] } {
		set line1 [lindex [split $outlines \n] 0]

		set distinfo [lassign $line1 hashhash branchrange]
		set remotebranch [lindex [split $branchrange .] end]
		if { $distinfo == "" } {
			set distance "(in head with $remotebranch)"
		} elseif { [string index $distinfo 0] == "\[" && [string index $distinfo end] == "\]" } {
			set distinfo [string range $distinfo 1 end-1]
			set direction [lindex $distinfo 0]
			if { $direction == "ahead" } {
				lappend direction of
			}
			set distance "([lindex $distinfo 1] $direction $remotebranch)"
		} else {
			set distance $distinfo
		}
	}

	set branch "BRANCH: $brname    OBJECT: $hhs   $distance"
	set hosted "HOSTED: $hosted"
	puts stderr "=$hosted"
	puts stderr "=$branch"
} else {
	set branch "DETACHED: $hdx"
	puts stderr "=$branch"
}

}


puts -nonewline stderr "Reading..."
set porc [exec git status {*}$git_options {*}$args]
puts -nonewline stderr "\r                                \r"

proc localize {cwd path} {

	if { [file pathtype $path] == "relative" } {
		return $path
	}

	set localcomp [file split $cwd]
	set path [file normalize $path] ;# for any case, skip any weird things
	# Check for simple strip
	if { [string first $cwd $path] == 0 } {
		return [string range $path [string length $cwd]+1 end]
	}

	set pathcomp [file split $path]

	# Find split point
	set len [llength $localcomp]
	for {set i 0} {$i < $len} {incr i} {
		if { [lindex $localcomp $i] != [lindex $pathcomp $i] } {
			break
		}
	}

	#puts stderr "PWD: $localcomp"
	#puts stderr "PTH: $pathcomp"
	#puts stderr "Mismatch at \[$i\]"

	# Strip common prefix
	set furthercomp [lrange $localcomp $i end]
	set pathcomp [lrange $pathcomp $i end]

	set updir [lrepeat [llength $furthercomp] ..]
	set comp [concat $updir $pathcomp]

	return [file join {*}$comp]
}

if { $only == "" } {
	puts stderr "=Stg View Path"
}

set sigmap {
	M mod
	A add
	R ren
	C cpy
	U upd
	D del
	" " ---
	? ???
}

array set sig $sigmap

proc screw path {
	if { !$::screwpath } {
		return "\"\$(git-top)/$path\""
	} elseif { 1+$::screwpath } {  ;# local
		return [localize [pwd] [file join $::top $path]]
	} else { ;# global
		return [file join $::top $path]
	}
}

foreach ln [split $porc \n] {
	set istage [string index $ln 0]
	set iview [string index $ln 1]
	set path [string range $ln 3 end] ;# [2] is space

	if { [llength $path] == 3 && [lindex $path 1] == "->" } {
		set tar [lindex $path 2]
		set path [lindex $path 0]
		set pathline "[screw $path] -> [screw $tar]"
	} else {
		set pathline [screw $path]
	}

	set sig_view "??$iview"
	set sig_stage "??$istage"
	if { [info exists sig($iview)] } {
		set sig_view $sig($iview)
	}
	if { [info exists sig($istage)] } {
		set sig_stage $sig($istage)
	}

	if { $onlyin == "view" } {
		set onlywanted { $sig_view == $only }
	} elseif { $onlyin == "stage" } {
		set onlywanted { $sig_stage == $only }
	} else {
		set onlywanted { $sig_view == $only || $sig_stage == $only } 
	}

	if { $only == "" } {
		puts " $sig_stage $sig_view $pathline"
	} elseif $onlywanted {
		puts $pathline
	}
}
