#!/usr/bin/tclsh

set screwpath 1
if { "-l" in $argv } {
	set screwpath 1
} elseif { "-g" in $argv } {
	set screwpath -1
} elseif { "-a" in $argv } {
	set screwpath 0
}

set git_options "--porcelain"

set only ""
set onlyin ""

set onlyopt [lsearch -inline $argv -o*]
if { $onlyopt != "" } {
	set oo [string range $onlyopt 2 end]
	while 1 {
		switch -- [string index $oo 0] {
			m { set only mod }
			a { set only add }
			d { set only del }
			o { set only ??? }
			u { set only ??? }
			s { set onlyin stage; set oo [string range $oo 1 end]; continue }
			v { set onlyin view; set oo [string range $oo 1 end]; continue }
			default {
				puts stderr "Incorrect -o (only) option: use one of: m, a, d, o, s, v"
				exit 1
			}
		}
		break
	}
}

# Show untacked (also if untracked-only)
if { "-u" ni $argv && $only != "???" } {
	lappend git_options -uno
}


set args ""
foreach a $argv {
	if { [string index $a 0] != "-" } {
		lappend args $a
	}
}

set top [exec git rev-parse --show-toplevel]

set gitdir $top/.git

if { [file isfile $gitdir] } {
	set gitdirspec [exec cat $gitdir]
	set gitdir [file join $top [lindex $gitdirspec 1]]
}

if { $only == "" } {

lassign [exec cat $gitdir/HEAD] hdx path
if { $hdx == "ref:" } {
	set brname [file tail $path]

	# Find the branch in the configuration
	if { [catch {set reponame [exec git config branch.$brname.remote]}] } {
		set reponame ""
	}
	if { $reponame == "" } { 
		set hosted "(LOCAL)"
	} else { 
		set repourl [exec git config remote.$reponame.url]
		set hosted "$reponame ($repourl)"
	}

	if { ![catch {set hh [exec git show --format=format:%H HEAD]}] } {
		set hh [lindex [split $hh \n] 0]
	} else {
		set hh "<NOT CREATED YET>"  ;# The initial case when HEAD does not exist
	}
	set branch "BRANCH: $brname    OBJECT: $hh"
	set hosted "HOSTED: $hosted"
	puts stderr "=$hosted"
	puts stderr "=$branch"
} else {
	set branch "DETACHED: $hdx"
	puts stderr "=$branch"
}

}


puts -nonewline stderr "Reading..."
set porc [exec git status {*}$git_options {*}$args]
puts -nonewline stderr "\r                                \r"

proc localize {cwd path} {

	if { [file pathtype $path] == "relative" } {
		return $path
	}

	set localcomp [file split $cwd]
	set path [file normalize $path] ;# for any case, skip any weird things
	# Check for simple strip
	if { [string first $cwd $path] == 0 } {
		return [string range $path [string length $cwd]+1 end]
	}

	set pathcomp [file split $path]

	# Find split point
	set len [llength $localcomp]
	for {set i 0} {$i < $len} {incr i} {
		if { [lindex $localcomp $i] != [lindex $pathcomp $i] } {
			break
		}
	}

	#puts stderr "PWD: $localcomp"
	#puts stderr "PTH: $pathcomp"
	#puts stderr "Mismatch at \[$i\]"

	# Strip common prefix
	set furthercomp [lrange $localcomp $i end]
	set pathcomp [lrange $pathcomp $i end]

	set updir [lrepeat [llength $furthercomp] ..]
	set comp [concat $updir $pathcomp]

	return [file join {*}$comp]
}

if { $only == "" } {
	puts stderr "=Stg View Path"
}

set sigmap {
	M mod
	A add
	R ren
	C cpy
	U upd
	D del
	" " ---
	? ???
}

array set sig $sigmap

proc screw path {
	if { !$::screwpath } {
		return "\"\$(git-top)/$path\""
	} elseif { 1+$::screwpath } {  ;# local
		return [localize [pwd] [file join $::top $path]]
	} else { ;# global
		return [file join $::top $path]
	}
}

foreach ln [split $porc \n] {
	set istage [string index $ln 0]
	set iview [string index $ln 1]
	set path [string range $ln 3 end] ;# [2] is space

	if { [llength $path] == 3 && [lindex $path 1] == "->" } {
		set tar [lindex $path 2]
		set path [lindex $path 0]
		set pathline "[screw $path] -> [screw $tar]"
	} else {
		set pathline [screw $path]
	}

	if { $onlyin == "view" } {
		set onlywanted { $sig($iview) == $only }
	} elseif { $onlyin == "stage" } {
		set onlywanted { $sig($istage) == $only }
	} else {
		set onlywanted { $sig($iview) == $only || $sig($istage) == $only } 
	}

	if { $only == "" } {
		puts " $sig($istage) $sig($iview) $pathline"
	} elseif $onlywanted {
		puts $pathline
	}
}
